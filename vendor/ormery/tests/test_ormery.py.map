{ "version": 3, "file": "py/ormery/tests/test_ormery.py", "sources": [ "-work/src/ormery.temper.md" ], "sourcesContent": [ "# ORMery - All-in-One Demo\n\nA simplified version of Ecto in Temper, using secure-composition for\ninjection-proof SQL generation.\n\n    let { sql, SqlFragment, SqlBuilder } = import(\u0022./sql\u0022);\n\n## Field and Schema\n\n    export class Field(\n      public name: String,\n      public fieldType: String,\n      public primaryKey: Boolean,\n      public nullable: Boolean,\n    ) {\n      public get description(): String {\n        let pk = if (primaryKey) { \u0022 (PK)\u0022 } else { \u0022\u0022 };\n        let null = if (nullable) { \u0022 (nullable)\u0022 } else { \u0022\u0022 };\n        \u0022\u0024{name}: \u0024{fieldType}\u0024{pk}\u0024{null}\u0022\n      }\n    }\n\n    export class Schema(\n      public tableName: String,\n      public fields: List\u003cField\u003e,\n    ) {\n      public getField(name: String): Field throws Bubble {\n        for (let field of fields) {\n          if (field.name == name) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public hasField(name: String): Boolean {\n        for (let field of fields) {\n          if (field.name == name) {\n            return true;\n          }\n        }\n        false\n      }\n\n      public get primaryKeyField(): Field throws Bubble {\n        for (let field of fields) {\n          if (field.primaryKey) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public get fieldNames(): List\u003cString\u003e {\n        fields.map { (f: Field): String =\u003e f.name }\n      }\n\n      public describe(): String {\n        let header = \u0022Schema: \u0024{tableName}\\n\u0022;\n        let fieldList = fields\n          .map { (f: Field): String =\u003e \u0022  - \u0024{f.description}\u0022 }\n          .join(\u0022\\n\u0022) { (s: String): String =\u003e s };\n        \u0022\u0024{header}\u0024{fieldList}\u0022\n      }\n    }\n\n    export let field(\n      name: String,\n      fieldType: String,\n      primaryKey: Boolean,\n      nullable: Boolean,\n    ): Field {\n      new Field(name, fieldType, primaryKey, nullable)\n    }\n\n### Identifier validation\n\nOnly allow safe SQL identifier characters: `a-z`, `A-Z`, `0-9`, `_`.\nThis closes the table name backdoor where `schema()` accepted arbitrary\nstrings that passed through `safeSql()` → `appendSafe()` unescaped.\n\n    export let isValidIdentifier(name: String): Boolean {\n      if (name.isEmpty) { return false; }\n      for (let c of name) {\n        if (c != char'_') {\n          if (c \u003e= char'a') {\n            if (c \u003e char'z') { return false; }\n          } else if (c \u003e= char'A') {\n            if (c \u003e char'Z') { return false; }\n          } else if (c \u003e= char'0') {\n            if (c \u003e char'9') { return false; }\n          } else {\n            return false;\n          }\n        }\n      }\n      true\n    }\n\n    export let schema(tableName: String, fields: List\u003cField\u003e): Schema {\n      if (!isValidIdentifier(tableName)) { panic(); }\n      let idField = new Field(\u0022id\u0022, \u0022Int\u0022, true, false);\n      let allFields = new ListBuilder\u003cField\u003e();\n      allFields.add(idField);\n      allFields.addAll(fields);\n      new Schema(tableName, allFields.toList())\n    }\n\n## Record and Store\n\n    export class Record(\n      public data: Map\u003cString, String\u003e,\n    ) {\n      public get(field: String): String throws Bubble {\n        data.get(field)\n      }\n\n      public getOr(field: String, fallback: String): String {\n        data.getOr(field, fallback)\n      }\n\n      public has(field: String): Boolean {\n        data.has(field)\n      }\n\n      public get id(): Int throws Bubble {\n        let idStr = data.get(\u0022id\u0022);\n        idStr.toInt32() orelse bubble()\n      }\n\n      public describe(): String {\n        let pairs = data.toListWith { (k: String, v: String): String =\u003e\n          \u0022\u0024{k}: \u0024{v}\u0022\n        };\n        pairs.join(\u0022, \u0022) { (s: String): String =\u003e s }\n      }\n    }\n\n    export class InMemoryStore() {\n      private var tables: MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e;\n      private var nextIds: MapBuilder\u003cString, Int\u003e;\n\n      public constructor() {\n        tables = new MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e();\n        nextIds = new MapBuilder\u003cString, Int\u003e();\n      }\n\n      private ensureTable(tableName: String): Void {\n        if (!tables.has(tableName)) {\n          tables.set(tableName, new ListBuilder\u003cRecord\u003e());\n          nextIds.set(tableName, 1);\n        }\n      }\n\n      public insert(tableName: String, data: Map\u003cString, String\u003e): Record {\n        ensureTable(tableName);\n        let id = nextIds.getOr(tableName, 1);\n        nextIds.set(tableName, id + 1);\n\n        let dataBuilder = data.toMapBuilder();\n        dataBuilder.set(\u0022id\u0022, id.toString());\n        let record = new Record(dataBuilder.toMap());\n\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.add(record);\n        record\n      }\n\n      public all(tableName: String): List\u003cRecord\u003e {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.toList()\n      }\n\n      public get(tableName: String, id: Int): Record throws Bubble {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n\n        for (let record of table.toList()) {\n          let recordId = record.id orelse bubble();\n          if (recordId == id) {\n            return record;\n          }\n        }\n        bubble()\n      }\n\n      public count(tableName: String): Int {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.length\n      }\n    }\n\n## Query Builder\n\n    export class WhereClause(\n      public field: String,\n      public operator: String,\n      public value: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{operator} \u0024{value}\u0022\n      }\n    }\n\n    export class OrderClause(\n      public field: String,\n      public direction: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{direction}\u0022\n      }\n    }\n\n    export class Query(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var whereClauses: ListBuilder\u003cWhereClause\u003e;\n      private var selectFields: List\u003cString\u003e;\n      private var orderByClauses: ListBuilder\u003cOrderClause\u003e;\n      private var limitValue: Int;\n      private var offsetValue: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        whereClauses = new ListBuilder\u003cWhereClause\u003e();\n        selectFields = [];\n        orderByClauses = new ListBuilder\u003cOrderClause\u003e();\n        limitValue = -1;\n        offsetValue = 0;\n      }\n\n      public where(field: String, operator: String, value: String): Query {\n        whereClauses.add(new WhereClause(field, operator, value));\n        this\n      }\n\n      public select(fields: List\u003cString\u003e): Query {\n        selectFields = fields;\n        this\n      }\n\n      public orderBy(field: String, direction: String): Query {\n        orderByClauses.add(new OrderClause(field, direction));\n        this\n      }\n\n      public limit(n: Int): Query {\n        limitValue = if (n \u003c 0) { 0 } else { n };\n        this\n      }\n\n      public offset(n: Int): Query {\n        offsetValue = n;\n        this\n      }\n\n      private matchesWhere(record: Record): Boolean {\n        for (let clause of whereClauses.toList()) {\n          let recordValue = record.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            return false;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let matches = when (fieldType) {\n            \u0022Int\u0022 -\u003e compareInt(recordValue, clause.operator, clause.value);\n            \u0022String\u0022 -\u003e compareString(recordValue, clause.operator, clause.value);\n            else -\u003e false;\n          };\n          if (!matches) {\n            return false;\n          }\n        }\n        true\n      }\n\n      private projectRecord(record: Record): Record {\n        if (selectFields.length == 0) {\n          return record;\n        }\n        let builder = new MapBuilder\u003cString, String\u003e();\n        for (let fieldName of selectFields) {\n          let value = record.getOr(fieldName, \u0022\u0022);\n          builder.set(fieldName, value);\n        }\n        new Record(builder.toMap())\n      }\n\n      private compareRecords(a: Record, b: Record, orderClauses: List\u003cOrderClause\u003e): Int {\n        for (let clause of orderClauses) {\n          let aVal = a.getOr(clause.field, \u0022\u0022);\n          let bVal = b.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            continue;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let cmp = when (fieldType) {\n            \u0022Int\u0022 -\u003e do {\n              let aInt = aVal.toInt32() orelse 0;\n              let bInt = bVal.toInt32() orelse 0;\n              aInt \u003c=\u003e bInt\n            };\n            \u0022String\u0022 -\u003e aVal \u003c=\u003e bVal;\n            else -\u003e 0;\n          };\n          if (cmp != 0) {\n            return if (clause.direction == \u0022desc\u0022) { -cmp } else { cmp };\n          }\n        }\n        0\n      }\n\n      public all(): List\u003cRecord\u003e {\n        let allRecords = store.all(schema.tableName);\n        let filtered = allRecords.filter { (r: Record): Boolean =\u003e\n          matchesWhere(r)\n        };\n        let sorted = if (orderByClauses.length \u003e 0) {\n          let clauses = orderByClauses.toList();\n          filtered.sorted { (a: Record, b: Record): Int =\u003e\n            compareRecords(a, b, clauses)\n          }\n        } else {\n          filtered\n        };\n        let sliced = if (limitValue \u003e= 0) {\n          let start = offsetValue;\n          let end = offsetValue + limitValue;\n          sorted.slice(start, end)\n        } else if (offsetValue \u003e 0) {\n          sorted.slice(offsetValue, sorted.length)\n        } else {\n          sorted\n        };\n        sliced.map { (r: Record): Record =\u003e projectRecord(r) }\n      }\n\n      public toSql(): SqlFragment {\n        toSqlQuery(schema, selectFields, whereClauses.toList(),\n                   orderByClauses.toList(), limitValue, offsetValue)\n      }\n    }\n\n    let compareInt(recordValue: String, operator: String, clauseValue: String): Boolean {\n      let rv = recordValue.toInt32() orelse 0;\n      let cv = clauseValue.toInt32() orelse 0;\n      if (clauseValue != cv.toString()) { return false; }\n      when (operator) {\n        \u0022==\u0022 -\u003e rv == cv;\n        \u0022!=\u0022 -\u003e rv != cv;\n        \u0022\u003e\u0022 -\u003e rv \u003e cv;\n        \u0022\u003c\u0022 -\u003e rv \u003c cv;\n        \u0022\u003e=\u0022 -\u003e rv \u003e= cv;\n        \u0022\u003c=\u0022 -\u003e rv \u003c= cv;\n        else -\u003e false;\n      }\n    }\n\n    let compareString(recordValue: String, operator: String, clauseValue: String): Boolean {\n      when (operator) {\n        \u0022==\u0022 -\u003e recordValue == clauseValue;\n        \u0022!=\u0022 -\u003e recordValue != clauseValue;\n        \u0022\u003e\u0022 -\u003e recordValue \u003e clauseValue;\n        \u0022\u003c\u0022 -\u003e recordValue \u003c clauseValue;\n        \u0022\u003e=\u0022 -\u003e recordValue \u003e= clauseValue;\n        \u0022\u003c=\u0022 -\u003e recordValue \u003c= clauseValue;\n        else -\u003e false;\n      }\n    }\n\n## SQL Generation\n\nPure functions that produce `SqlFragment` from query state using\nsecure-composition's `sql\u0022...\u0022` tagged strings. Interpolated values are\nautomatically escaped by type. Trusted SQL identifiers (table names, column\nnames, operators) are composed via fragment nesting.\n\n### Operator validation\n\nOnly allow known SQL comparison operators. Returns the operator if valid,\nor `=` as a safe fallback.\n\n    let validOperator(op: String): String {\n      when (op) {\n        \u0022=\u0022 -\u003e \u0022=\u0022;\n        \u0022==\u0022 -\u003e \u0022=\u0022;\n        \u0022!=\u0022 -\u003e \u0022!=\u0022;\n        \u0022\u003c\u003e\u0022 -\u003e \u0022\u003c\u003e\u0022;\n        \u0022\u003e\u0022 -\u003e \u0022\u003e\u0022;\n        \u0022\u003c\u0022 -\u003e \u0022\u003c\u0022;\n        \u0022\u003e=\u0022 -\u003e \u0022\u003e=\u0022;\n        \u0022\u003c=\u0022 -\u003e \u0022\u003c=\u0022;\n        else -\u003e \u0022=\u0022;\n      }\n    }\n\n### Trusted identifier fragment\n\nWraps a trusted identifier (table name, column name, operator) as a\n`SqlFragment`. These come from schema definitions, not user input.\n\n    let safeSql(trusted: String): SqlFragment {\n      let b = new SqlBuilder();\n      b.appendSafe(trusted);\n      b.accumulated\n    }\n\n### Column list helper\n\nBuilds the SELECT column list. If no fields specified, returns `*`.\n\n    let columnListSql(selectFields: List\u003cString\u003e): SqlFragment {\n      if (selectFields.length == 0) {\n        sql\u0022*\u0022\n      } else {\n        let first = safeSql(selectFields[0]);\n        var result = sql\u0022\u0024{first}\u0022;\n        for (var i = 1; i \u003c selectFields.length; i = i + 1) {\n          let col = safeSql(selectFields[i]);\n          result = sql\u0022\u0024{result}, \u0024{col}\u0022;\n        }\n        result\n      }\n    }\n\n### WHERE clause helper\n\nBuilds a single WHERE condition. The value is untrusted user input —\n`sql\u0022...\u0022` escapes it by type automatically.\n\n    let whereConditionSql(clause: WhereClause, schema: Schema): SqlFragment {\n      let col = safeSql(clause.field);\n      let op = safeSql(validOperator(clause.operator));\n      let fieldInfo = schema.getField(clause.field) orelse panic();\n      if (fieldInfo.fieldType == \u0022Int\u0022) {\n        let intVal = clause.value.toInt32() orelse 0;\n        if (clause.value != intVal.toString()) {\n          sql\u00221 = 0\u0022\n        } else {\n          sql\u0022\u0024{col} \u0024{op} \u0024{intVal}\u0022\n        }\n      } else {\n        let strVal = clause.value;\n        sql\u0022\u0024{col} \u0024{op} \u0024{strVal}\u0022\n      }\n    }\n\n### ORDER BY clause helper\n\n    let orderBySql(clauses: List\u003cOrderClause\u003e): SqlFragment {\n      let first = safeSql(clauses[0].field);\n      let firstDir = if (clauses[0].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n      var result = sql\u0022\u0024{first}\u0024{firstDir}\u0022;\n      for (var i = 1; i \u003c clauses.length; i = i + 1) {\n        let col = safeSql(clauses[i].field);\n        let dir = if (clauses[i].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n        result = sql\u0022\u0024{result}, \u0024{col}\u0024{dir}\u0022;\n      }\n      result\n    }\n\n### Full SELECT query builder\n\nAssembles a complete SELECT statement from parts. This is the main pure\nfunction: it takes query state in, returns `SqlFragment` out. Field names\nare validated against the schema — only declared fields pass through\n`safeSql`. Unknown fields are silently dropped, closing the confused deputy\nvector where user-controlled strings could reach `appendSafe`.\n\n    export let toSqlQuery(\n      schema: Schema,\n      selectFields: List\u003cString\u003e,\n      whereClauses: List\u003cWhereClause\u003e,\n      orderClauses: List\u003cOrderClause\u003e,\n      limitValue: Int,\n      offsetValue: Int,\n    ): SqlFragment {\n      let validSelect = selectFields.filter { (f: String): Boolean =\u003e\n        schema.hasField(f)\n      };\n      let validWhere = whereClauses.filter { (c: WhereClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let validOrder = orderClauses.filter { (c: OrderClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let table = safeSql(schema.tableName);\n      let cols = columnListSql(validSelect);\n      var result = sql\u0022SELECT \u0024{cols} FROM \u0024{table}\u0022;\n      if (validWhere.length \u003e 0) {\n        var conditions = whereConditionSql(validWhere[0], schema);\n        for (var i = 1; i \u003c validWhere.length; i = i + 1) {\n          let next = whereConditionSql(validWhere[i], schema);\n          conditions = sql\u0022\u0024{conditions} AND \u0024{next}\u0022;\n        }\n        result = sql\u0022\u0024{result} WHERE \u0024{conditions}\u0022;\n      }\n      if (validOrder.length \u003e 0) {\n        let ordering = orderBySql(validOrder);\n        result = sql\u0022\u0024{result} ORDER BY \u0024{ordering}\u0022;\n      }\n      if (limitValue \u003e= 0) {\n        result = sql\u0022\u0024{result} LIMIT \u0024{limitValue}\u0022;\n      }\n      if (offsetValue \u003e 0) {\n        result = sql\u0022\u0024{result} OFFSET \u0024{offsetValue}\u0022;\n      }\n      result\n    }\n\n### INSERT statement builder\n\nGenerates an INSERT statement from a schema and a map of field values.\nField names come from the schema (trusted). Values are escaped via\n`sql\u0022...\u0022` by type.\n\n    export let toInsertSql(\n      schema: Schema,\n      values: Map\u003cString, String\u003e,\n    ): SqlFragment {\n      let table = safeSql(schema.tableName);\n      let fieldList = schema.fields.filter { (f: Field): Boolean =\u003e\n        values.has(f.name)\n      };\n      if (fieldList.length == 0) {\n        return sql\u0022\u0022;\n      }\n      let colNames = columnListSql(\n        fieldList.map { (f: Field): String =\u003e f.name }\n      );\n      let firstVal = values.getOr(fieldList[0].name, \u0022\u0022);\n      var vals = if (fieldList[0].fieldType == \u0022Int\u0022) {\n        let iv = firstVal.toInt32() orelse 0;\n        sql\u0022\u0024{iv}\u0022\n      } else {\n        sql\u0022\u0024{firstVal}\u0022\n      };\n      for (var i = 1; i \u003c fieldList.length; i = i + 1) {\n        let val = values.getOr(fieldList[i].name, \u0022\u0022);\n        if (fieldList[i].fieldType == \u0022Int\u0022) {\n          let iv = val.toInt32() orelse 0;\n          vals = sql\u0022\u0024{vals}, \u0024{iv}\u0022;\n        } else {\n          vals = sql\u0022\u0024{vals}, \u0024{val}\u0022;\n        }\n      }\n      sql\u0022INSERT INTO \u0024{table} (\u0024{colNames}) VALUES (\u0024{vals})\u0022\n    }\n\n## SQL Generation Tests\n\n### Basic SELECT\n\n    test(\u0022toSql: select all\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n### SELECT with specific columns\n\n    test(\u0022toSql: select columns\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).select([\u0022name\u0022, \u0022age\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name, age FROM users\u0022);\n    }\n\n### WHERE with string value\n\n    test(\u0022toSql: where string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### WHERE with integer value\n\n    test(\u0022toSql: where int\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18\u0022);\n    }\n\n### SQL injection protection\n\nThe Bobby Tables attack string is safely escaped — single quotes are doubled.\n\n    test(\u0022toSql: SQL injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, bobby);\n      let result = q.toSql().toString();\n      assert(result == \u0022SELECT * FROM users WHERE name = 'Robert''); DROP TABLE users;--'\u0022);\n    }\n\n### Operator normalization\n\nThe `==` operator from the in-memory query API is normalized to SQL `=`.\n\n    test(\u0022toSql: operator normalization\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022==\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Invalid operator fallback\n\nUnknown operators fall back to `=` for safety.\n\n    test(\u0022toSql: invalid operator fallback\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022LIKE\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Multiple WHERE clauses\n\n    test(\u0022toSql: multiple where\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .where(\u0022age\u0022, \u0022\u003c\u0022, \u002230\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18 AND age \u003c 30\u0022);\n    }\n\n### ORDER BY\n\n    test(\u0022toSql: order by\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022name\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY name ASC\u0022);\n    }\n\n### ORDER BY descending\n\n    test(\u0022toSql: order by desc\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022age\u0022, \u0022desc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY age DESC\u0022);\n    }\n\n### LIMIT and OFFSET\n\n    test(\u0022toSql: limit\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(10);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 10\u0022);\n    }\n\n    test(\u0022toSql: offset\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).offset(5);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users OFFSET 5\u0022);\n    }\n\n### Complex query\n\n    test(\u0022toSql: complex query\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10)\n        .offset(20);\n      assert(q.toSql().toString() ==\n        \u0022SELECT name, age FROM users WHERE age \u003e= 18 ORDER BY age DESC LIMIT 10 OFFSET 20\u0022);\n    }\n\n### Unicode in values\n\n    test(\u0022toSql: unicode escaping\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Hello 世界\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Hello 世界'\u0022);\n    }\n\n### Embedded quotes in values\n\n    test(\u0022toSql: embedded quotes\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022O'Brien\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'O''Brien'\u0022);\n    }\n\n### Empty string value\n\n    test(\u0022toSql: empty string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = ''\u0022);\n    }\n\n### INSERT statement\n\n    test(\u0022toInsertSql: basic insert\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022INSERT INTO users (name, age) VALUES ('Alice', 25)\u0022);\n    }\n\n### INSERT with injection protection\n\n    test(\u0022toInsertSql: injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Robert'); DROP TABLE users;--\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() ==\n        \u0022INSERT INTO users (name) VALUES ('Robert''); DROP TABLE users;--')\u0022);\n    }\n\n### toSqlQuery as standalone pure function\n\n    test(\u0022toSqlQuery: standalone\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let result = toSqlQuery(\n        s, [\u0022name\u0022], [new WhereClause(\u0022age\u0022, \u0022\u003e\u0022, \u002221\u0022)],\n        [new OrderClause(\u0022name\u0022, \u0022asc\u0022)], 5, 0,\n      );\n      assert(result.toString() ==\n        \u0022SELECT name FROM users WHERE age \u003e 21 ORDER BY name ASC LIMIT 5\u0022);\n    }\n\n### Adversarial field name protection\n\nField names not in the schema are silently dropped from SQL generation.\nThis prevents confused deputy attacks where user-controlled strings\ncould reach `appendSafe` through field name positions.\n\n    test(\u0022toSql: adversarial field name blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u00221=1; DROP TABLE users; --\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial select column blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u00221; DROP TABLE users\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial order by blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .orderBy(\u00221; DROP TABLE users\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n## Security Audit Fix Tests\n\n### Fix #1: Table name validation\n\n    test(\u0022isValidIdentifier: valid names\u0022) {\n      assert(isValidIdentifier(\u0022users\u0022));\n      assert(isValidIdentifier(\u0022user_table\u0022));\n      assert(isValidIdentifier(\u0022Table1\u0022));\n      assert(isValidIdentifier(\u0022_private\u0022));\n      assert(isValidIdentifier(\u0022a\u0022));\n    }\n\n    test(\u0022isValidIdentifier: invalid names\u0022) {\n      assert(!isValidIdentifier(\u0022\u0022));\n      assert(!isValidIdentifier(\u0022users; DROP TABLE\u0022));\n      assert(!isValidIdentifier(\u0022users--\u0022));\n      assert(!isValidIdentifier(\u0022ta ble\u0022));\n      assert(!isValidIdentifier(\u0022table.name\u0022));\n      assert(!isValidIdentifier(\u0022Robert'); DROP TABLE users;--\u0022));\n    }\n\n### Fix #3: Non-numeric value for Int field\n\n    test(\u0022toSql: non-numeric Int value produces always-false\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE 1 = 0\u0022);\n    }\n\n    test(\u0022in-memory: non-numeric Int value matches nothing\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u00220\u0022),\n      ]));\n      let results = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022).all();\n      assert(results.length == 0);\n    }\n\n### Fix #5: LIMIT zero and negative\n\n    test(\u0022toSql: limit zero emits LIMIT 0\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(0);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 0\u0022);\n    }\n\n    test(\u0022in-memory: limit zero returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(0).all();\n      assert(results.length == 0);\n    }\n\n    test(\u0022in-memory: negative limit clamped to zero\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(-5).all();\n      assert(results.length == 0);\n    }\n\n### Fix #6: Empty insert safety\n\n    test(\u0022toInsertSql: no matching fields returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022nonexistent\u0022, \u0022value\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022\u0022);\n    }\n\n## Demo\n\n    export let main(): Void {\n      console.log(\u0022=== ORMery Demo ===\\n\u0022);\n\n      let userFields = [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n        field(\u0022email\u0022, \u0022String\u0022, false, true),\n      ];\n      let userSchema = schema(\u0022users\u0022, userFields);\n\n      console.log(userSchema.describe());\n      console.log(\u0022\u0022);\n\n      let store = new InMemoryStore();\n\n      let rec1 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n        new Pair(\u0022email\u0022, \u0022alice@example.com\u0022),\n      ]));\n\n      let rec2 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Bob\u0022),\n        new Pair(\u0022age\u0022, \u002230\u0022),\n        new Pair(\u0022email\u0022, \u0022bob@example.com\u0022),\n      ]));\n\n      let rec3 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Charlie\u0022),\n        new Pair(\u0022age\u0022, \u002217\u0022),\n        new Pair(\u0022email\u0022, \u0022charlie@example.com\u0022),\n      ]));\n\n      console.log(\u0022Inserted 3 users:\u0022);\n      console.log(\u0022  \u0024{rec1.describe()}\u0022);\n      console.log(\u0022  \u0024{rec2.describe()}\u0022);\n      console.log(\u0022  \u0024{rec3.describe()}\u0022);\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== In-Memory Queries ===\\n\u0022);\n\n      console.log(\u0022All users:\u0022);\n      let allUsers = new Query(userSchema, store).all();\n      for (let u of allUsers) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022Adults (age \u003e= 18):\u0022);\n      let adults = new Query(userSchema, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .all();\n      for (let u of adults) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== SQL Generation (secure-composition) ===\\n\u0022);\n\n      let q1 = new Query(userSchema, store);\n      console.log(\u0022SELECT all: \u0024{q1.toSql().toString()}\u0022);\n\n      let q2 = new Query(userSchema, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10);\n      console.log(\u0022Complex:    \u0024{q2.toSql().toString()}\u0022);\n\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q3 = new Query(userSchema, store)\n        .where(\u0022name\u0022, \u0022=\u0022, bobby);\n      console.log(\u0022Injection:  \u0024{q3.toSql().toString()}\u0022);\n\n      let insertVals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022O'Malley\u0022),\n        new Pair(\u0022age\u0022, \u002242\u0022),\n      ]);\n      console.log(\u0022INSERT:     \u0024{toInsertSql(userSchema, insertVals).toString()}\u0022);\n\n      console.log(\u0022\\n=== Demo Complete ===\u0022);\n    }\n" ], "names": [ "SqlFragment", "SqlBuilder", "Test", "TestCase", "str", "bool", "int", "MappingProxyType", "Sequence", "schema", "field", "Schema", "InMemoryStore", "Query", "str_cat#5818", "map_constructor#5847", "Pair#5846", "toInsertSql", "toSqlQuery", "WhereClause", "OrderClause", "isValidIdentifier", "Record", "len#5816", "int_to_string#5821", "test#17", "s", "store", "q", "actual#831", "t#3717", "fn", "test#18", "actual#834", "t#3708", "test#19", "actual#837", "t#3698", "test#20", "actual#840", "t#3688", "test#21", "bobby", "result", "actual#843", "t#3678", "test#22", "actual#846", "t#3668", "test#23", "actual#849", "t#3658", "test#24", "actual#852", "t#3648", "test#25", "actual#855", "t#3637", "test#26", "actual#858", "t#3627", "test#27", "actual#861", "t#3617", "test#28", "actual#864", "t#3607", "test#29", "actual#867", "t#3597", "test#30", "actual#870", "t#3583", "test#31", "actual#873", "t#3573", "test#32", "actual#876", "t#3563", "test#33", "vals", "actual#879", "t#3553", "test#34", "actual#882", "t#3543", "test#35", "actual#885", "t#3534", "test#36", "actual#888", "t#3523", "test#37", "actual#891", "t#3513", "test#38", "actual#894", "t#3503", "test#39", "t#3480", "t#3483", "t#3486", "t#3489", "t#3492", "test#40", "t#3453", "t#3457", "t#3461", "t#3465", "t#3469", "t#3473", "test#41", "actual#899", "t#3443", "test#42", "results", "actual#902", "t#3433", "test#43", "actual#905", "t#3417", "test#44", "actual#908", "t#3407", "test#45", "actual#911", "t#3392", "test#46", "actual#914", "t#3377" ], "mappings": "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" }