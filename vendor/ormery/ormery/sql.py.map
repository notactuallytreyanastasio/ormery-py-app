{ "version": 3, "file": "py/ormery/ormery/sql.py", "sourceRoot": "-work/src/sql/", "sources": [ "builder.temper.md", "model.temper.md", "tests.temper.md" ], "sourcesContent": [ "# SQL Query Builder\n\n## The `sql` tag\n\nThis builds a semi-structured *SqlFragment* representation that then can have\nvalues rendered for various DB dialects.\n\nTODO Would it be possible to extract a \u0022prepared statement\u0022 form as well? Could\nthat be recognized and cached instead of rebuilt each time?\n\n    export let sql = SqlBuilder;\n\n    export class SqlBuilder {\n      private let buffer: ListBuilder\u003cSqlPart\u003e = new ListBuilder();\n\n### appendSafe\n\n      public appendSafe(sqlSource: String): Void {\n        buffer.add(new SqlSource(sqlSource));\n      }\n\n### appendSqlFragment\n\nAdd the contents of another SQL fragment to this one.\n\n      @overload(\u0022append\u0022)\n      public appendFragment(fragment: SqlFragment): Void {\n        buffer.addAll(fragment.parts);\n      }\n\n### appendSqlPart\n\nAdd a single already qualified SQL part to this builder.\n\n      @overload(\u0022append\u0022)\n      public appendPart(part: SqlPart): Void {\n        buffer.add(part);\n      }\n\n### appendSqlPartList\n\n      @overload(\u0022append\u0022)\n      public appendPartList(values: List\u003cSqlPart\u003e): Void {\n        appendList(values) { (x: SqlPart) =\u003e appendPart(x) };\n      }\n\n### appendBoolean\n\n      @overload(\u0022append\u0022)\n      public appendBoolean(value: Boolean): Void {\n        buffer.add(new SqlBoolean(value));\n      }\n\n### appendBooleanList\n\n      @overload(\u0022append\u0022)\n      public appendBooleanList(values: Listed\u003cBoolean\u003e): Void {\n        appendList(values) { (x: Boolean) =\u003e appendBoolean(x) };\n      }\n\n### appendDate\n\nThe Temper date type naturally formats to YYYY-MM-DD, which is the standard SQL\ndate format.\n\n      @overload(\u0022append\u0022)\n      public appendDate(value: Date): Void {\n        buffer.add(new SqlDate(value));\n      }\n\n### appendDateList\n\n      @overload(\u0022append\u0022)\n      public appendDateList(values: Listed\u003cDate\u003e): Void {\n        appendList(values) { (x: Date) =\u003e appendDate(x) };\n      }\n\n### appendFloat64\n\n      @overload(\u0022append\u0022)\n      public appendFloat64(value: Float64): Void {\n        buffer.add(new SqlFloat64(value));\n      }\n\n### appendFloat64List\n\n      @overload(\u0022append\u0022)\n      public appendFloat64List(values: Listed\u003cFloat64\u003e): Void {\n        appendList(values) { (x: Float64) =\u003e appendFloat64(x) };\n      }\n\n### appendInt32\n\n      @overload(\u0022append\u0022)\n      public appendInt32(value: Int32): Void {\n        buffer.add(new SqlInt32(value));\n      }\n\n### appendInt32List\n\n      @overload(\u0022append\u0022)\n      public appendInt32List(values: Listed\u003cInt32\u003e): Void {\n        appendList(values) { (x: Int32) =\u003e appendInt32(x) };\n      }\n\n### appendInt64\n\n      @overload(\u0022append\u0022)\n      public appendInt64(value: Int64): Void {\n        buffer.add(new SqlInt64(value));\n      }\n\n### appendInt64List\n\n      @overload(\u0022append\u0022)\n      public appendInt64List(values: Listed\u003cInt64\u003e): Void {\n        appendList(values) { (x: Int64) =\u003e appendInt64(x) };\n      }\n\n### appendString\n\n      @overload(\u0022append\u0022)\n      public appendString(value: String): Void {\n        buffer.add(new SqlString(value));\n      }\n\n### appendStringList\n\n      @overload(\u0022append\u0022)\n      public appendStringList(values: Listed\u003cString\u003e): Void {\n        appendList(values) { (x: String) =\u003e appendString(x) };\n      }\n\n### appendList\n\nThis is a helper to make other list append methods easier.\n\n      private appendList\u003cT\u003e(values: Listed\u003cT\u003e, appendValue: Appender\u003cT\u003e): Void {\n        for (var i = 0; i \u003c values.length; i++) {\n          if (i \u003e 0) {\n            appendSafe(\u0022, \u0022);\n          }\n          appendValue(values[i]);\n        }\n      }\n\n### accumulated\n\nTODO Instead make some kind of Statement type.\n\n      public get accumulated(): SqlFragment {\n        new SqlFragment(buffer.toList())\n      }\n    }\n\n## Helper types\n\n    @fun interface Appender\u003cT\u003e(value: T): Void;\n", "# SQL Data Model\n\nWe build an abstract model that can be rendered to different dialects.\n\n## SqlFragment\n\nThe fragment class supports semi-structured raw SQL text and data values, which\nthen can be escaped differently for different dbs. And while called a\n\u0022fragment\u0022, an instance can also represent a full statement.\n\n    export class SqlFragment(\n      public parts: List\u003cSqlPart\u003e,\n    ) {\n\n### toSource\n\nFreeze this to string source content marked as safe SQL.\n\nTODO Make different forms for different dialects.\n\n      public toSource(): SqlSource {\n        new SqlSource(toString())\n      }\n\n### toString\n\nTODO Make different forms for different dialects.\n\n      public toString(): String {\n        let builder = new StringBuilder();\n        for (var i = 0; i \u003c parts.length; ++i) {\n          parts[i].formatTo(builder);\n        }\n        builder.toString()\n      }\n\n    }\n\n## SqlPart\n\nEach part of a SQL fragment is either raw known-safe SQL source or else a value\nneeding escaped and/or represented properly for a particular DB dialect.\n\nTODO If we represent SQL syntax in a structured way, we could perhaps do more.\n\n    export sealed interface SqlPart {\n\n### formatTo\n\nEnables using a single StringBuilder across multiple parts for efficiency.\n\nTODO Different dialects.\n\n      public formatTo(builder: StringBuilder): Void;\n\n    }\n\n### SqlSource\n\n`SqlSource` represents known-safe SQL source code that doesn't need escaped. This\noften originates from the raw string content in `sql`-tagged strings. For\nexample, in `sql\u0022select p.name from person p where p.id = \u0024{id}\u0022`, all except\nthe `\u0024{id}` interpolation becomes a `SqlSource` instance.\n\n    export class SqlSource(public source: String) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(source);\n      }\n\n    }\n\n### SqlBoolean\n\n    export class SqlBoolean(public value: Boolean) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(if (value) { \u0022TRUE\u0022 } else { \u0022FALSE\u0022 });\n      }\n\n    }\n\n### SqlDate\n\n    export class SqlDate(public value: Date) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(\u0022'\u0022);\n        let s = value.toString();\n        for (let c of s) {\n          if (c == char'\\'') {\n            builder.append(\u0022''\u0022);\n          } else {\n            builder.appendCodePoint(c) orelse panic();\n          }\n        }\n        builder.append(\u0022'\u0022);\n      }\n\n    }\n\n### SqlFloat64\n\n    export class SqlFloat64(public value: Float64) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(value.toString());\n      }\n\n    }\n\n### SqlInt32\n\n    export class SqlInt32(public value: Int32) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(value.toString());\n      }\n\n    }\n\n### SqlInt64\n\n    export class SqlInt64(public value: Int64) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(value.toString());\n      }\n\n    }\n\n### SqlString\n\n`SqlString` represents text data that needs escaped.\n\n    export class SqlString(public value: String) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(\u0022'\u0022);\n        for (let c of value) {\n          if (c == char'\\'') {\n            builder.append(\u0022''\u0022);\n          } else {\n            builder.appendCodePoint(c) orelse panic();\n          }\n        }\n        builder.append(\u0022'\u0022);\n      }\n\n    }\n", "# SqlBuilder tests\n\n## String escaping\n\nTODO Test for all dialects together?\n\n    test(\u0022string escaping\u0022) {\n      let build(name: String): String {\n        sql\u0022select * from hi where name = \u0024{name}\u0022.toString()\n      }\n      let buildWrong(name: String): String {\n        \u0022select * from hi where name = '\u0024{name}'\u0022\n      }\n\nTry an easy case and also little Bobby.\n\n      assert(build(\u0022world\u0022) == \u0022select * from hi where name = 'world'\u0022);\n      let bobbyTables = \u0022Robert'); drop table hi;--\u0022;\n      assert(\n        build(bobbyTables) ==\n          \u0022select * from hi where name = 'Robert''); drop table hi;--'\u0022\n      );\n\nAlso show why we care with a failed case.\n\n      assert(\n        buildWrong(bobbyTables) ==\n          \u0022select * from hi where name = 'Robert'); drop table hi;--'\u0022\n      );\n    }\n\n## String edge cases\n\nWe don't parse the SQL itself, so we can test subexpressions without worrying\ncontext.\n\nNote that we don't have the ability to compose SQL syntax itself in these\ntemplates.\n\n    test(\u0022string edge cases\u0022) {\n      assert(sql\u0022v = \u0024{\u0022\u0022}\u0022.toString() == \u0022v = ''\u0022);\n      assert(sql\u0022v = \u0024{\u0022a''b\u0022}\u0022.toString() == \u0022v = 'a''''b'\u0022);\n      assert(sql\u0022v = \u0024{\u0022Hello 世界\u0022}\u0022.toString() == \u0022v = 'Hello 世界'\u0022);\n\nTODO Which databases allow for multiline strings? Seems sqlite does:\n\n```sql\nsqlite\u003e select 'line 1\n'  ...\u003e line 2';\nline 1\nline 2\nsqlite\u003e\n```\n\n      assert(sql\u0022v = \u0024{\u0022Line1\\nLine2\u0022}\u0022.toString() == \u0022v = 'Line1\\nLine2'\u0022);\n    }\n\n## Numbers and Booleans\n\n    test(\u0022numbers and booleans\u0022) {\n      assert(\n        sql\u0022select \u0024{42}, \u0024{43i64}, \u0024{19.99}, \u0024{true}, \u0024{false}\u0022.toString() ==\n          \u0022select 42, 43, 19.99, TRUE, FALSE\u0022\n      );\n      let date = new Date(2024, 12, 25) orelse panic();\n      assert(\n        sql\u0022insert into t values (\u0024{date})\u0022.toString() ==\n          \u0022insert into t values ('2024-12-25')\u0022\n      );\n    }\n\n## Lists\n\nLists go in comma-separated, with each element escaped as appropriate.\n\nTODO If contextual, we could put parens around automatically when needed.\n\n    test(\u0022lists\u0022) {\n      assert(\n        sql\u0022v IN (\u0024{[\u0022a\u0022, \u0022b\u0022, \u0022c'd\u0022]})\u0022.toString() == \u0022v IN ('a', 'b', 'c''d')\u0022\n      );\n      assert(sql\u0022v IN (\u0024{[1, 2, 3]})\u0022.toString() == \u0022v IN (1, 2, 3)\u0022);\n      assert(sql\u0022v IN (\u0024{[1i64, 2i64]})\u0022.toString() == \u0022v IN (1, 2)\u0022);\n      assert(sql\u0022v IN (\u0024{[1.0, 2.0]})\u0022.toString() == \u0022v IN (1.0, 2.0)\u0022);\n      assert(sql\u0022v IN (\u0024{[true, false]})\u0022.toString() == \u0022v IN (TRUE, FALSE)\u0022);\n      let dates = [\n        new Date(2024, 1, 1) orelse panic(),\n        new Date(2024, 12, 25) orelse panic(),\n      ];\n      assert(\n        sql\u0022v IN (\u0024{dates})\u0022.toString() == \u0022v IN ('2024-01-01', '2024-12-25')\u0022\n      );\n    }\n\n## Nesting\n\nPut already escaped SQL into another SQL fragment.\n\n    test(\u0022nesting\u0022) {\n      let name = \u0022Someone\u0022;\n      let condition = sql\u0022where p.last_name = \u0024{name}\u0022;\n\nFirst check adding expanded semi-structured fragment content.\n\n      assert(\n        sql\u0022select p.id from person p \u0024{condition}\u0022.toString() ==\n          \u0022select p.id from person p where p.last_name = 'Someone'\u0022\n      );\n\nAlso check adding content frozen to SQL source.\n\n      assert(\n        sql\u0022select p.id from person p \u0024{condition.toSource()}\u0022.toString() ==\n          \u0022select p.id from person p where p.last_name = 'Someone'\u0022\n      );\n\nWe can also append individual parts.\n\n      let parts: List\u003cSqlPart\u003e = [new SqlString(\u0022a'b\u0022), new SqlInt32(3)];\n      assert(sql\u0022select \u0024{parts}\u0022.toString() == \u0022select 'a''b', 3\u0022);\n    }\n" ], "names": [ "MutableSequence", "Sequence", "Any", "TypeVar", "Callable", "str", "bool", "float", "int", "list", "RuntimeError", "len", "tuple", "date", "ABCMeta", "string_from_code_point", "list_builder_add_all", "list_get", "int_add", "date_to_string", "string_for_each", "float64_to_string", "int_to_string", "str_cat", "list_builder_add_all#5760", "len#5761", "list_get#5762", "int_add#5763", "tuple#5764", "list#5765", "date_to_string#5769", "string_for_each#5771", "float64_to_string#5772", "int_to_string#5773", "str_cat#5774", "date#5775", "T", "SqlBuilder", "buffer", "this", "sqlSource", "t#1163", "SqlSource", "fragment", "t#1161", "part", "values", "fn", "x", "value", "t#1154", "SqlBoolean", "t#1148", "SqlDate", "t#1142", "SqlFloat64", "t#1136", "SqlInt32", "t#1130", "SqlInt64", "t#1124", "SqlString", "appendList", "appendValue", "t#1116", "t#1118", "i", "SqlFragment", "t#1113", "parts", "t#1186", "builder", "SqlPart", "source", "t#718", "s", "c", "t#1175", "t#1173", "t#1171" ], "mappings": "A,mB,e,I,iB,E,Q,I,U,E,G,I,K,E,O,I,S,E,Q,I;A,qB,G,I,K,E,I,I,M,E,K,I,O,E,G,I,K,E,I,I,K,E,Y,I,c,E,G,I,I,E,K,I;A,qB,I,I;A,gB,O,I;A,wB,sB,I,wB,E,oB,I,qB,E,Q,I,S,E,O,I,Q,E,c,I,e,E,e,I,gB,E,iB,I,kB,E,a,I,c,E,O,I;AD2BewB,yBDAM,EDAA,ADAN,CDAAR;AD+GoBS,QDAM,EDAA,ADAN,CDAAd;ADIPe,aDAA,GDAAT,SDAA;ADJeU,YDAA,GDAAT;ADaZU,UDAM,EDAA,ADAN,CDAAhB,MDAM;AD1IgBiB,SDAW,EDAA,ADAX,CDAApB,KDAW;ADiF1CqB,mBDAQ,EDAA,ADAR,CDAAX;ADCCY,oBDAE,EDAA,ADAF,CDAAX;ADmBMY,sBDAQ,EDAA,ADAR,CDAAX;ADYAY,kBDAQ,EDAA,ADAR,CDAAX,cDAQ;ADnH7BY,YDAA,GDAAX;ADqDaY,SDAI,EDAA,ADAJ,CDAAtB,MDAI;ADyEAuB,IDAC,EDAA,ADAD,CDAAjC,SDAC,CDAA,ADAD,MDAC,CDAA,ADAD,MDAC,GDAAD,KDAA,CDAA;AD7HT,MDAAmC,UDAA;ADCC,IDAAC,SDAM,CDAE,6BDAwC;ADDjD,aD4IV,EDAA,AD5IU,EDCH,WDAoD,ED2I3D;ADvIM,mBDEN,CDAA,ADFiBC,MDAA,EDAAC,aDAS,CDAE,QDE5B,IDAA,ADFqC,ODAI;ADC7B,QDAAC,MDAwB,CDAA,ADAxB,YDAwB,EDAA,ADApB,CDAAC,SDAS,CDACF,aDAS,CDAC;ADAnC,QDAAD,MDAM,CDAAD,SDAA,CDAA,ADAN,MDAoC,CDAA,ADAzBG,MDAwB;ADQ9B,uBDEN,CDAA,ADFqBF,ODAA,EDAAI,WDAQ,CDAE,cDE/B,IDAA,ADF6C,ODAI;ADClC,QDAAC,MDAc,CDAA,ADAd,sBDAc,EDAA,ADAd,CDAAD,WDAQ,CDAM,KDAA;ADArB,QDAAnB,yBDAM,CDAA,ADAbe,ODAM,CDAAD,SDAA,CDAQ,CDAAM,MDAc;ADQvB,mBDEN,CDAA,ADFiBL,ODAA,EDAAM,QDAI,CDAE,UDEvB,IDAA,ADFiC,ODAI;ADCpC,QDAAN,ODAM,CDAAD,SDAA,CDAA,ADAN,MDAgB,CDAA,ADALO,QDAI;ADMV,wBDEN,CDAA,ADFqBN,ODAA,EDAAO,UDAM,CDAE,sBDE7B,IDAA,ADF6C,ODAI;ADC7B,YDAAC,ODAA,CDAGC,KDAC,CDAE,UDA2B,IDAA,ADAf;ADAA,YDAAT,ODAU,CDAA,ADAV,WDAU,CDACS,KDAC,CDAC;ADAlD,QDAAT,ODAU,CDAA,ADAV,eDAU,CDACO,UDAM,CDAE,CDAAC,ODAiC;ADM/C,sBDEN,CDAA,ADFoBR,ODAA,EDAAU,SDAK,CDAE,SDE3B,IDAA,ADFqC,ODAI;ADC7B,QDAAC,MDAqB,CDAA,ADArB,aDAqB,EDAA,ADAjB,CDAAC,UDAU,CDACF,SDAK,CDAC;ADAhC,QDAAV,ODAM,CDAAD,SDAA,CDAA,ADAN,MDAiC,CDAA,ADAtBY,MDAqB;ADM3B,2BDEN,CDAA,ADFwBX,ODAA,EDAAO,UDAM,CDAE,qBDEhC,IDAA,ADFkD,ODAI;ADClC,YDAAC,ODAA,CDAGC,KDAC,CDAE,SDA8B,IDAA,ADAlB;ADAA,YDAAT,ODAa,CDAA,ADAb,cDAa,CDACS,KDAC,CDAC;ADArD,QDAAT,ODAU,CDAA,ADAV,eDAU,CDACO,UDAM,CDAE,CDAAC,ODAoC;ADSlD,mBDEN,CDAA,ADFiBR,ODAA,EDAAU,SDAK,CDAE,SDExB,IDAA,ADF+B,ODAI;ADCvB,QDAAG,MDAkB,CDAA,ADAlB,UDAkB,EDAA,ADAd,CDAAC,ODAO,CDACJ,SDAK,CDAC;ADA7B,QDAAV,ODAM,CDAAD,SDAA,CDAA,ADAN,MDA8B,CDAA,ADAnBc,MDAkB;ADMxB,wBDEN,CDAA,ADFqBb,ODAA,EDAAO,UDAM,CDAE,qBDE7B,IDAA,ADF4C,ODAI;ADC5B,YDAAC,ODAA,CDAGC,KDAC,CDAE,SDAwB,IDAA,ADAf;ADAA,YDAAT,ODAU,CDAA,ADAV,WDAU,CDACS,KDAC,CDAC;ADA/C,QDAAT,ODAU,CDAA,ADAV,eDAU,CDACO,UDAM,CDAE,CDAAC,ODA8B;ADM5C,sBDEN,CDAA,ADFoBR,ODAA,EDAAU,SDAK,CDAE,UDE3B,IDAA,ADFqC,ODAI;ADC7B,QDAAK,MDAqB,CDAA,ADArB,aDAqB,EDAA,ADAjB,CDAAC,UDAU,CDACN,SDAK,CDAC;ADAhC,QDAAV,ODAM,CDAAD,SDAA,CDAA,ADAN,MDAiC,CDAA,ADAtBgB,MDAqB;ADM3B,2BDEN,CDAA,ADFwBf,ODAA,EDAAO,UDAM,CDAE,sBDEhC,IDAA,ADFkD,ODAI;ADClC,YDAAC,ODAA,CDAGC,KDAC,CDAE,UDA8B,IDAA,ADAlB;ADAA,YDAAT,ODAa,CDAA,ADAb,cDAa,CDACS,KDAC,CDAC;ADArD,QDAAT,ODAU,CDAA,ADAV,eDAU,CDACO,UDAM,CDAE,CDAAC,ODAoC;ADMlD,oBDEN,CDAA,ADFkBR,ODAA,EDAAU,SDAK,CDAE,QDEzB,IDAA,ADFiC,ODAI;ADCzB,QDAAO,MDAmB,CDAA,ADAnB,WDAmB,EDAA,ADAf,CDAAC,QDAQ,CDACR,SDAK,CDAC;ADA9B,QDAAV,ODAM,CDAAD,SDAA,CDAA,ADAN,MDA+B,CDAA,ADApBkB,MDAmB;ADMzB,yBDEN,CDAA,ADFsBjB,ODAA,EDAAO,UDAM,CDAE,oBDE9B,IDAA,ADF8C,ODAI;ADC9B,YDAAC,ODAA,CDAGC,KDAC,CDAE,QDA0B,IDAA,ADAhB;ADAA,YDAAT,ODAW,CDAA,ADAX,YDAW,CDACS,KDAC,CDAC;ADAjD,QDAAT,ODAU,CDAA,ADAV,eDAU,CDACO,UDAM,CDAE,CDAAC,ODAgC;ADM9C,oBDEN,CDAA,ADFkBR,ODAA,EDAAU,SDAK,CDAE,WDEzB,IDAA,ADFiC,ODAI;ADCzB,QDAAS,MDAmB,CDAA,ADAnB,WDAmB,EDAA,ADAf,CDAAC,QDAQ,CDACV,SDAK,CDAC;ADA9B,QDAAV,ODAM,CDAAD,SDAA,CDAA,ADAN,MDA+B,CDAA,ADApBoB,MDAmB;ADMzB,yBDEN,CDAA,ADFsBnB,ODAA,EDAAO,UDAM,CDAE,uBDE9B,IDAA,ADF8C,ODAI;ADC9B,YDAAC,ODAA,CDAGC,KDAC,CDAE,WDA0B,IDAA,ADAhB;ADAA,YDAAT,ODAW,CDAA,ADAX,YDAW,CDACS,KDAC,CDAC;ADAjD,QDAAT,ODAU,CDAA,ADAV,eDAU,CDACO,UDAM,CDAE,CDAAC,ODAgC;ADM9C,qBDEN,CDAA,ADFmBR,ODAA,EDAAU,SDAK,CDAE,QDE1B,IDAA,ADFmC,ODAI;ADC3B,QDAAW,MDAoB,CDAA,ADApB,YDAoB,EDAA,ADAhB,CDAAC,SDAS,CDACZ,SDAK,CDAC;ADA/B,QDAAV,ODAM,CDAAD,SDAA,CDAA,ADAN,MDAgC,CDAA,ADArBsB,MDAoB;ADM1B,0BDEN,CDAA,ADFuBrB,ODAA,EDAAO,UDAM,CDAE,oBDE/B,IDAA,ADFgD,ODAI;ADChC,YDAAC,ODAA,CDAGC,KDAC,CDAE,QDA4B,IDAA,ADAjB;ADAA,YDAAT,ODAY,CDAA,ADAZ,aDAY,CDACS,KDAC,CDAC;ADAnD,QDAAT,ODAU,CDAA,ADAV,eDAU,CDACO,UDAM,CDAE,CDAAC,ODAkC;ADO/C,QDAAe,eDOP,CDAA,ADPqBvB,ODAA,EDAAO,UDAM,CDAE,mBDAS,CDAE,CDAAiB,gBDAW,CDAE,2BDOrD,IDAA,ADPmE,ODAI;ADClD,QDAAC,MDAa,CDAA,ADAb;ADIN,QDAAC,MDAS,CDAA,ADAT,ODAS;ADJd,QDAAC,KDAC,CDAA,ADAD,QDAC,EDAG,EDAC;ADAd;ADAoB,YDAAF,MDAA,EDAO,CDAAvC,QDAM,CDAA,ADAbqB,UDAM,CDAO;ADAjB,kBDAiB,ADAjB,CDAAoB,KDAC,ADAD,EDAI,CDAAF,MDAa;ADAA;ADC/B,cDAI,CDAAE,KDAC,ADAD,EDAI,EDAC;ADCP,gBDAA3B,ODAU,CDAA,ADAV,WDAU,CDAC,IDAI;ADEL,YDAA0B,MDAA,EDAM,CDAAvC,aDAA,CDAA,ADANoB,UDAM,CDAC,CDAAoB,KDAC,CDAC;ADArB,YDAAH,gBDAW,CDACE,MDAS,CDAC;ADJW,YDAAC,KDAC,EDAA,ADAD,CDAAvC,YDAA,CDAAuC,KDAC;ADY/B;ADAA,mBDEN,CDAA,ADFuB3B,ODEvB,IDAA,ADFyB,cDAW;ADCnC,cDAI,CDAA4B,WDAW,CDAQvC,UDAM,CDAA,ADAbW,ODAM,CDAAD,SDAA,CDAS,CDChC;AD5IU,ODAW,UDAAC,ODAA;ADCqB,QDAA6B,MDAiB,CDAA,ADAjB,6BDAiB,EDAA,ADAb,CDAAvC,SDAW,EDAE;ADAhD,QDAAU,ODAA,CDAgDD,SDAA,EDAA,ADAjB,CDAA8B,MD2I1C;AD9IU,MDAAD,WDAA;ADCJ,IDAAE,SDAK,CDAE,sBDAa;ADDhB,aDwBV,EDAA,ADxBU,EDCJ,WDAoB,EDuB1B;ADdM,iBDEN,CDAA,ADFgB9B,ODEhB,IDAA,ADFkB,YDAS;ADC1B,cDAI,CDAAG,SDAS,CDACH,ODAQ,CDAA,ADAR,SDAQ,EDAE;ADOnB,iBDMN,CDAA,ADNgBA,ODMhB,IDAA,ADNkB,QDAM;ADEH,QDAA+B,MDAY,CDAA,ADAZ,QDAY;ADD5B,QDAAC,WDAO,CDAA,ADAP,eDAO,EDAG,IDAmB;ADCxB,QDAAL,KDAC,CDAA,ADAD,QDAC,EDAG,EDAC;ADAd;ADAoB,YDAAI,MDAA,EDAM,CDAA7C,QDAM,CDAA,ADAZc,ODAK,CDAA8B,SDAA,CDAO;ADAhB,kBDAgB,ADAhB,CDAAH,KDAC,ADAD,EDAI,CDAAI,MDAY;ADAA,qBDCrB;ADAJ,YDAA5C,aDAA,CDAA,ADALa,ODAK,CDAA8B,SDAA,CDAC,CDAAH,KDAC,CDAC,CDAA,ADAR,SDAiB,CDACK,WDAO,CDAC;ADDQ,YDAAL,KDAC,EDAA,ADAD,CDAAvC,YDAC,CDAA,ADADuC,KDAC;ADGrC,uBDAAK,WDAO,CDAA;ADvBE,ODEX,UDAAhC,ODAA,CDAA,ADDO,CDAA8B,SDAK,CDAE,sBDCd,UDAA;ADDO,QDAA9B,ODAA,CDAoB8B,SDAA,EDAA,ADApB,CDAAA,SDuBN;ADvBM;ADAA,cDAA9B,QDAA;ADAA,eDAAA,QDAA,CDAA8B;ADkCe,MDAAG,ODAA,UDQuB,EDAA,ADRvB,CDAA1D,SDQuB,EDAA;ADAtC,iBDAsC,CDAA,ADA7ByB,ODAA,EDAAgC,WDAO,CDAE,eDAoB,IDAA,ADAJ,ODAI;ADAA,cDAA7D,cDAA;ADWlC,MDAAgC,SDAA,CDAA8B,ODMV,EDAA;ADNU;ADAiB,IDAAC,UDAM,CDAE,QDAM;ADA/B,aDMV,EDAA,ADNU,EDAiB,YDAc,EDMzC;ADFM,iBDEN,CDAA,ADFelC,ODAA,EDAAgC,WDAO,CDAE,eDExB,IDAA,ADFwC,ODAI;ADC3C,QDAAA,WDAO,CDAA,ADAP,MDAsB,CDAA,ADAPhC,ODAM,CDAAkC,UDAA,CDCtB;ADNU,ODAiD,UDAAlC,ODAA,CDAA,ADAhC,CDAAkC,UDAM,CDAE,QDAwB,UDAA;ADAhC,QDAAlC,ODAA,CDAckC,UDAA,EDAA,ADAd,CDAAA,UDM3B;ADN2B;ADAA,eDAAlC,QDAA;ADAA,eDAAA,QDAA,CDAAkC;ADYjB,MDAAtB,UDAA,CDAAqB,ODMV,EDAA;ADN4B,IDAAvB,SDAK,CDAE,SDAO;ADAhC,aDMV,EDAA,ADNU,EDAkB,WDAc,EDM1C;ADFM,iBDEN,CDAA,ADFeV,ODAA,EDAAgC,WDAO,CDAE,eDExB,IDAA,ADFwC,ODAI;ADCjB,QDAAG,KDAU,CDAA,ADAV,QDAU;ADArB,UDAI,CDAAnC,ODAK,CDAAU,SDAA;ADAI,YDAAyB,KDAA,SDAM;ADAN;ADAgB,YDAAA,KDAA,UDAO;ADAnD,QDAAH,WDAO,CDAA,ADAP,MDAsD,CDAA,ADAvCG,KDAsC,CDCtD;ADNU,ODAkD,UDAAnC,ODAA,CDAA,ADAhC,CDAAU,SDAK,CDAE,SDAyB,UDAA;ADAhC,QDAAV,ODAA,CDAcU,SDAA,EDAA,ADAd,CDAAA,SDM5B;ADN4B;ADAA,cDAAV,QDAA;ADAA,eDAAA,QDAA,CDAAU;ADYlB,MDAAI,ODAA,CDAAmB,ODeV,EDAA;ADfyB,IDAAvB,SDAK,CDAE,SDAI;ADA1B,aDeV,EDAA,ADfU,EDAe,WDAW,EDepC;ADXM,iBDWN,CDAA,ADXeV,ODAA,EDAAgC,WDAO,CDAE,eDWxB,IDAA,ADXwC,ODAI;ADC3C,QDAAA,WDAO,CDAA,ADAP,MDAmB,CDAA,ADAJ,GDAG;ADCd,QDAAI,KDAC,CDAA,ADAD,QDAC,EDAS,CDAA7C,mBDAQ,CDAA,ADAdS,ODAK,CDAAU,SDAA;ADCI,YDAAF,ODAA,CDAA,ADAR6B,KDAC,CDAA,ADAD,QDMR,IDAA,ADNgB;ADCf,cDAI,CDAAA,KDAC,ADAD,GDAK,GDAQ;ADCf,gBDAAL,WDAO,CDAA,ADAP,MDAoB,CDAA,ADAL,IDAI;ADAC;ADEpB,gBDAAA,WDAO,CDAA,ADAP,MDA0B,CDAA,ADAF,yBDAAK,KDAC,EDC1B;ADLY,QDAA7C,oBDAE,CDAA,ADAH4C,KDAC,CDAE,CDAA5B,ODMhB,CDAA;ADCD,QDAAwB,WDAO,CDAA,ADAP,MDAmB,CDAA,ADAJ,GDAG,CDCnB;ADfU,ODA4C,UDAAhC,ODAA,CDAA,ADA7B,CDAAU,SDAK,CDAE,SDAsB,UDAA;ADA7B,QDAAV,ODAA,CDAWU,SDAA,EDAA,ADAX,CDAAA,SDezB;ADfyB;ADAA,cDAAV,QDAA;ADAA,eDAAA,QDAA,CDAAU;ADqBf,MDAAM,UDAA,CDAAiB,ODMV,EDAA;ADN4B,IDAAvB,SDAK,CDAE,UDAO;ADAhC,aDMV,EDAA,ADNU,EDAkB,WDAc,EDM1C;ADFM,iBDEN,CDAA,ADFeV,ODAA,EDAAgC,WDAO,CDAE,eDExB,IDAA,ADFwC,ODAI;ADC5B,QDAAM,MDAgB,CDAA,ADAhB,QDAgB,EDAA,ADAV,CDAA7C,sBDAQ,CDAA,ADAdO,ODAK,CDAAU,SDAA,CDAW;ADA/B,QDAAsB,WDAO,CDAA,ADAP,MDAgC,CDAA,ADAjBM,MDAgB,CDChC;ADNU,ODAkD,UDAAtC,ODAA,CDAA,ADAhC,CDAAU,SDAK,CDAE,UDAyB,UDAA;ADAhC,QDAAV,ODAA,CDAcU,SDAA,EDAA,ADAd,CDAAA,SDM5B;ADN4B;ADAA,cDAAV,QDAA;ADAA,eDAAA,QDAA,CDAAU;ADYlB,MDAAQ,QDAA,CDAAe,ODMV,EDAA;ADN0B,IDAAvB,SDAK,CDAE,QDAK;ADA5B,aDMV,EDAA,ADNU,EDAgB,WDAY,EDMtC;ADFM,iBDEN,CDAA,ADFeV,ODAA,EDAAgC,WDAO,CDAE,eDExB,IDAA,ADFwC,ODAI;ADC5B,QDAAO,MDAgB,CDAA,ADAhB,QDAgB,EDAA,ADAV,CDAA7C,kBDAQ,CDAA,ADAdM,ODAK,CDAAU,SDAA,CDAW;ADA/B,QDAAsB,WDAO,CDAA,ADAP,MDAgC,CDAA,ADAjBO,MDAgB,CDChC;ADNU,ODA8C,UDAAvC,ODAA,CDAA,ADA9B,CDAAU,SDAK,CDAE,QDAuB,UDAA;ADA9B,QDAAV,ODAA,CDAYU,SDAA,EDAA,ADAZ,CDAAA,SDM1B;ADN0B;ADAA,cDAAV,QDAA;ADAA,eDAAA,QDAA,CDAAU;ADYhB,MDAAU,QDAA,CDAAa,ODMV,EDAA;ADN0B,IDAAvB,SDAK,CDAE,WDAK;ADA5B,aDMV,EDAA,ADNU,EDAgB,WDAY,EDMtC;ADFM,iBDEN,CDAA,ADFeV,ODAA,EDAAgC,WDAO,CDAE,eDExB,IDAA,ADFwC,ODAI;ADC5B,QDAAQ,MDAgB,CDAA,ADAhB,QDAgB,EDAA,ADAV,CDAA9C,kBDAQ,CDAA,ADAdM,ODAK,CDAAU,SDAA,CDAW;ADA/B,QDAAsB,WDAO,CDAA,ADAP,MDAgC,CDAA,ADAjBQ,MDAgB,CDChC;ADNU,ODA8C,UDAAxC,ODAA,CDAA,ADA9B,CDAAU,SDAK,CDAE,WDAuB,UDAA;ADA9B,QDAAV,ODAA,CDAYU,SDAA,EDAA,ADAZ,CDAAA,SDM1B;ADN0B;ADAA,cDAAV,QDAA;ADAA,eDAAA,QDAA,CDAAU;ADchB,MDAAY,SDAA,CDAAW,ODcV,EDAA;ADdU;ADAiB,IDAAvB,SDAK,CDAE,QDAM;ADA9B,aDcV,EDAA,ADdU,EDAiB,WDAa,EDcxC;ADVM,iBDUN,CDAA,ADVeV,ODAA,EDAAgC,WDAO,CDAE,eDUxB,IDAA,ADVwC,ODAI;ADC3C,QDAAA,WDAO,CDAA,ADAP,MDAmB,CDAA,ADAJ,GDAG;ADCG,YDAAxB,ODAA,CDAA,ADAZ6B,KDAC,CDAA,ADAD,QDMR,IDAA,ADNoB;ADCnB,cDAI,CDAAA,KDAC,ADAD,GDAK,GDAQ;ADCf,gBDAAL,WDAO,CDAA,ADAP,MDAoB,CDAA,ADAL,IDAI;ADAC;ADEpB,gBDAAA,WDAO,CDAA,ADAP,MDA0B,CDAA,ADAF,yBDAAK,KDAC,EDC1B;ADLgB,QDAA7C,oBDAE,CDAA,ADAPQ,ODAK,CDAAU,SDAA,CDAE,CDAAF,ODMpB,CDAA;ADCD,QDAAwB,WDAO,CDAA,ADAP,MDAmB,CDAA,ADAJ,GDAG,CDCnB;ADdU,ODAgD,UDAAhC,ODAA,CDAA,ADA/B,CDAAU,SDAK,CDAE,QDAwB,UDAA;ADA/B,QDAAV,ODAA,CDAaU,SDAA,EDAA,ADAb,CDAAA,SDc3B;ADd2B;ADAA,cDAAV,QDAA;ADAA,eDAAA,QDAA,CDAAU,SDc3B" }